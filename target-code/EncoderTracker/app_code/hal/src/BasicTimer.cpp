//###########################################################################
// BasicTimer.cpp
// Hardware Layer class that manages a single BasicTimer module
//
// $Copyright: Copyright (C) LDO Systems
//###########################################################################
#include "BasicTimer.h"
#include "AppHeaders.h"

BaseTimer::BaseTimer()
{
}


///Configure the timer channel
void BaseTimer::Initialize(TimerChannel timchannel)
{
	base = (TIM_TypeDef*)timchannel;
	if (_Tim6 == timchannel)
	{
		RCC->APB1ENR = (RCC->APB1ENR & ~RCC_APB1ENR_TIM6EN_Msk) | RCC_APB1ENR_TIM6EN;
	}
	else if (_Tim7 == timchannel)
	{
		RCC->APB1ENR = (RCC->APB1ENR & ~RCC_APB1ENR_TIM7EN_Msk) | RCC_APB1ENR_TIM7EN;
	}
}


///Remaps the Update Interrupt Flag to bit 31 of the TIMx_CNT register.
///This allows for simultaneous read of the timer count and update interrupt flag
void BaseTimer::RemapUif(bool isRemap)
{
	base->CR1 = (base->CR1 &  ~TIM_CR1_UIFREMAP_Msk) | (isRemap << TIM_CR1_UIFREMAP_Pos);
}


///Enables or disables auto-reload preload
///Enabling ensures that the auto-reload values are not updated
///until the update/overflow event occurs
void BaseTimer::ToggleAutoReloadPreload(bool enablePreload)
{
	base->CR1 = (base->CR1 & ~TIM_CR1_ARPE_Msk) | (enablePreload << TIM_CR1_ARPE_Pos);
}


///When one pulse mode is enabled, the counter stops at the next update event - clearing the CEN bit
void BaseTimer::ToggleOnePulseMode(bool enableOnePulseMode)
{
	base->CR1 = (base->CR1 & ~TIM_CR1_OPM_Msk) | (enableOnePulseMode << TIM_CR1_OPM_Pos);
}


///select the UEV event sources
///_FurtherRequestSource: Any of the following events generates an update interrupt or DMA request if enabled.
///These events can be :
/// - Counter overflow / underflow
/// - Setting the UG bit
/// - Update generation through the slave mode controller
///_CounterFlowOnly:Only counter overflow/underflow generates an update interrupt or DMA request if
///enabled
void BaseTimer::SelectUpdateRequestSource(UpdateRequestSource updaterequestsource)
{
	base->CR1 = (base->CR1 & ~TIM_CR1_URS_Msk) | (updaterequestsource << TIM_CR1_URS_Pos);
}


///Disables or enables auto update event generation
///Disabling prevents shadow registers from updating their values
void BaseTimer::ToggleAutoUpdateEvent(bool isDisableAutoUpdateEvent)
{
	base->CR1 = (base->CR1 & ~TIM_CR1_UDIS_Msk) | ((~isDisableAutoUpdateEvent) << TIM_CR1_UDIS_Pos);
}


///These Func is used to select the information to be sent in master mode to slave timers for
///synchronization(TRGO).The combination is as follows :
///_MMS_0 : Reset - the UG bit from the TIMx_EGR register is used as a trigger output(TRGO).If
///reset is generated by the trigger input(slave mode controller configured in reset mode) then
///the signal on TRGO is delayed compared to the actual reset.
///_MMS_1 : Enable - the Counter enable signal, CNT_EN, is used as a trigger output(TRGO).It is
///useful to start several timers at the same time or to control a window in which a slave timer
///is enabled.The Counter Enable signal is generated by a logic OR between CEN control bit
///and the trigger input when configured in gated mode.
///When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO,
///except if the master / slave mode is selected(see the MSM bit description in the TIMx_SMCR
///	register).
///	_MMS_2: Update - The update event is selected as a trigger output
void BaseTimer::ConfigMasterModeSelection(MasterModeSelection mastermodeselection)
{
	base->CR2 = (base->CR2 & ~TIM_CR2_MMS_Msk) | (mastermodeselection << TIM_CR2_MMS_Pos);
}


///Toggles whether a DMA request is generated on an update event
void BaseTimer::ToggleUpdateDmaRequest(bool enable)
{
	base->DIER = (base->DIER & ~TIM_DIER_UDE_Msk) | (enable << TIM_DIER_UDE_Pos);
}


///Toggles whether an interrupt is generated on an update event
void BaseTimer::ToggleUpdateInterrupt(bool enable)
{
	base->DIER = (base->DIER & ~TIM_DIER_UIE_Msk) | (enable << TIM_DIER_UIE_Pos);
}
